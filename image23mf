#!/usr/bin/env python

from PIL import Image, ImagePalette
from sys import argv

from xml.dom.minidom import getDOMImplementation

from zipfile import ZipFile
import uuid
from datetime import datetime

## Configuration

SIZE = 70 # mm
HOLE_SIZE = 0.8 # mm
HOLE_DENSITY_PERCENT = 100 # %

COHESION_LAYER_HEIGHT = 1
COLOR_LAYER_HEIGHT = 0.6

## End configuration

INPUT_IMAGE_PATH = argv[1]

HOLE_DENSITY = HOLE_DENSITY_PERCENT * 0.4 / 100

RESOLUTION = int(SIZE / HOLE_SIZE)
HOLE_COUNT = int(RESOLUTION * HOLE_DENSITY)
SCALE = SIZE / RESOLUTION

HOLE_FREQUENCY = round((RESOLUTION - HOLE_SIZE * SCALE * HOLE_COUNT) / HOLE_COUNT)
HOLE_OFFSET = int(HOLE_FREQUENCY / 2)
DITHER = False

class Layer:
    def __init__(self, z, thickness, scale, size):
        self.z = z
        self.thickness = thickness
        self.scale = scale

        self.triangles = []
        self.vertices = {}

        self.grid = [[False for _ in range(size[1])] for _ in range(size[0])]

    def vertices_for(self, x, y):
        # Define the 8 vertices of the pixel
        scaled_x = x * self.scale
        scaled_y = y * self.scale

        vertices = [
            [scaled_x,               scaled_y,                self.z                  ],
            [scaled_x + self.scale,  scaled_y,                self.z                  ],
            [scaled_x + self.scale,  scaled_y + self.scale,   self.z                  ],
            [scaled_x,               scaled_y + self.scale,   self.z                  ],
            [scaled_x,               scaled_y,                self.z + self.thickness ],
            [scaled_x + self.scale,  scaled_y,                self.z + self.thickness ],
            [scaled_x + self.scale,  scaled_y + self.scale,   self.z + self.thickness ],
            [scaled_x,               scaled_y + self.scale,   self.z + self.thickness ]
        ]

        return vertices
    
    def put_pixel(self, x, y):
        self.grid[x][y] = True

    def put_floor_and_ceiling(self, x, y):
        triangles = [
            # Floor
            [3, 1, 0],
            [3, 2, 1],

            # Ceiling
            [4, 5, 6],
            [4, 6, 7],
        ]

        for triangle in triangles:
            self.put_triangle(triangle=triangle, x=x, y=y)

    def put_wall(self, x, y, direction):

        triangles = []

        if direction == "left":
            triangles = [

                [7, 3, 0],
                [4, 7, 0]
            ]
        elif direction == "right":
            triangles = [
                [6, 5, 1],
                [6, 1, 2]

            ]
        elif direction == "top":
            triangles = [
                [7, 6, 2],
                [3, 7, 2]
            ]
        elif direction == "bottom":
            triangles = [
                [0, 5, 4],
                [1, 5, 0]
            ]
        
        for triangle in triangles:
            self.put_triangle(triangle=triangle, x=x, y=y)

    def put_triangle(self, x, y, triangle):
        vertices = self.vertices_for(x, y)

        global_vertex_indices = []

        for vertex_index in triangle:
            vertex = vertices[vertex_index]
            global_vertex_indices.append(self.find_or_create_vertex(vertex))

        self.triangles.append(global_vertex_indices)

    def find_or_create_vertex(self, vertex):
        rounded_vertex = tuple(map(lambda x: round(x, 4), vertex))
        vertex_key = 'x'.join(map(str, rounded_vertex))

        if vertex_key in self.vertices:
            return self.vertices[vertex_key]
        else:
            vertex_index = len(self.vertices)
            self.vertices[vertex_key] = vertex_index
            return vertex_index

    def build_geometry(self):
        # For now we only have a top and bottom faces, we must add some walls
        for x in range(len(self.grid)):
            for y in range(len(self.grid[x])):
                if not self.grid[x][y]:
                    continue

                self.put_floor_and_ceiling(x=x, y=y)

                # Check if we need to add a wall on the left
                if x == 0 or not self.grid[x - 1][y]:
                    self.put_wall(x=x, y=y, direction="left")

                # Check if we need to add a wall on the right
                if x == len(self.grid) - 1 or not self.grid[x + 1][y]:
                    self.put_wall(x=x, y=y, direction="right")

                # Check if we need to add a wall on the bottom
                if y == 0 or not self.grid[x][y - 1]:
                    self.put_wall(x=x, y=y, direction="bottom")

                # Check if we need to add a wall on the top
                if y == len(self.grid[x]) - 1 or not self.grid[x][y + 1]:
                    self.put_wall(x=x, y=y, direction="top")

def add_layer_to_model(document, layer, id, paint_color):
    layer.build_geometry()

    # Make sure the required nodes are present
    try:
        resources_element = document.getElementsByTagName("resources")[0]
    except IndexError:
        resources_element = document.createElement("resources")
        document.documentElement.appendChild(resources_element)

    try:
        build_element = document.getElementsByTagName("build")[0]
    except IndexError:
        build_element = document.createElement("build")
        document.documentElement.appendChild(build_element)

    object_element = document.createElement("object")
    object_element.setAttribute("id", id)
    object_element.setAttribute("type", "model")
    resources_element.appendChild(object_element)

    mesh_element = document.createElement("mesh")
    object_element.appendChild(mesh_element)

    vertices_element = document.createElement("vertices")
    mesh_element.appendChild(vertices_element)

    triangles_element = document.createElement("triangles")
    mesh_element.appendChild(triangles_element)

    item_element = document.createElement("item")
    item_element.setAttribute("objectid", id)
    item_element.setAttribute("transform", "1 0 0 0 1 0 0 0 1 90 90 0")
    item_element.setAttribute("printable", "1")
    build_element.appendChild(item_element)

    for vertex in layer.vertices.keys():
        x, y, z = vertex.split('x')

        vertice = document.createElement("vertex")
        vertice.setAttribute("x", x)
        vertice.setAttribute("y", y)
        vertice.setAttribute("z", z)
        vertices_element.appendChild(vertice)

    for face in layer.triangles:
        v1_index, v2_index, v3_index = face

        triangle_element = document.createElement("triangle")
        triangle_element.setAttribute("v1", str(v1_index))
        triangle_element.setAttribute("v2", str(v2_index))
        triangle_element.setAttribute("v3", str(v3_index))
        # triangle_element.setAttribute("paint_color", paint_color)
        triangles_element.appendChild(triangle_element)

def create_model_document():
    model_document = getDOMImplementation().createDocument(None, "model", None)

    model_document.documentElement.setAttribute("unit", "millimeter")
    model_document.documentElement.setAttribute("xml:lang", "en-US")
    model_document.documentElement.setAttribute("xmlns", "http://schemas.microsoft.com/3dmanufacturing/core/2015/02")

    return model_document

colors_configuration = {
    "black":    [ 0, 0, 0],
    "white":    [ 255, 255, 255 ],
    "blue":     [ 0, 120, 191 ]
}

flat_colors = []
for rgb in colors_configuration.values():
    flat_colors.append(rgb[0])
    flat_colors.append(rgb[1])
    flat_colors.append(rgb[2])

palette = ImagePalette.ImagePalette(palette=flat_colors * 32) # Why 32?

with Image.open(INPUT_IMAGE_PATH) as image:
    if image.mode == "RGBA":
        rgb_image = Image.new("RGB", image.size, (255, 255, 255))
        rgb_image.paste(image, mask=image.split()[3]) # remove alpha channel
    else:
        rgb_image = image

    resized_image = rgb_image.resize((RESOLUTION, RESOLUTION), Image.LANCZOS)

    image_palette = Image.new('P', resized_image.size)
    image_palette.putpalette(palette)

    quantized_image = resized_image.quantize(
        dither=Image.Dither.FLOYDSTEINBERG if DITHER else Image.Dither.NONE,
        palette=image_palette
    )
    quantized_image_data = quantized_image.load()

    cohesion_layer = Layer(z=0, thickness=COHESION_LAYER_HEIGHT, scale=SCALE, size=(quantized_image.size[0], quantized_image.size[1]))
    color_layers = {}

    model_document = create_model_document()

    for x in range(quantized_image.size[0]):
        for y in range(quantized_image.size[1]):
            # Skip holes
            is_hole = (x + HOLE_OFFSET) % HOLE_FREQUENCY == 0 and (y + HOLE_OFFSET) % HOLE_FREQUENCY == 0
            if is_hole:
                continue

            # Add cohesion layer (ie, a tall pixel under each colored pixel to serve as a platform)
            cohesion_layer.put_pixel(x=x, y=y)

            for index, color in enumerate(colors_configuration.keys()):
                if quantized_image_data[x, y] != index:
                    continue

                color_layers.setdefault(
                    color,
                    Layer(z=COHESION_LAYER_HEIGHT, thickness=COLOR_LAYER_HEIGHT, scale=SCALE, size=(quantized_image.size[0], quantized_image.size[1]))
                )
                color_layers[color].put_pixel(x=x, y=y)

    add_layer_to_model(document=model_document, layer=cohesion_layer, id="1", paint_color="1")

    # for index, (color, layer) in enumerate(color_layers.items()):
    #     add_layer_to_model(document=model_document, layer=layer, id=str(index + 2), paint_color="2")

    now = datetime.now().strftime("%m%d%Y%H%M%S")
    output_file_path = f"output-{now}.3mf"

    with ZipFile(output_file_path, 'w') as output_zip:
        output_zip.writestr('[Content_Types].xml', '''<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/>
</Types>''')

        output_zip.writestr('_rels/.rels', '''<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Target="/3D/3dmodel.model" Id="rel-1" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel"/>
</Relationships>''')

        output_zip.writestr('3D/3dmodel.model', model_document.toprettyxml(encoding="utf-8"))
