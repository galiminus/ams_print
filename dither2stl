#!/usr/bin/env python

from PIL import Image, ImagePalette
from sys import argv

import numpy as np
import stl
from stl import mesh

SIZE = 70 # mm
RES = 130
BASE_THICKNESS = 0.5
THICKNESS = 0.75 # mm

SCALE = SIZE / RES

def put_pixel(x, y, z, thickness):
    if int(x / 2) % 2 == 0 and int(y / 2) % 2 == 0:
        return None

    scaled_x = x * SCALE
    scaled_y = y * SCALE

    # Define the 8 vertices of the cube
    vertices = np.array([
        [scaled_x,          scaled_y,           z            ],
        [scaled_x + SCALE,  scaled_y,           z            ],
        [scaled_x + SCALE,  scaled_y + SCALE,   z            ],
        [scaled_x,          scaled_y + SCALE,   z            ],
        [scaled_x,          scaled_y,           z + thickness],
        [scaled_x + SCALE,  scaled_y,           z + thickness],
        [scaled_x + SCALE,  scaled_y + SCALE,   z + thickness],
        [scaled_x,          scaled_y + SCALE,   z + thickness]
    ])

    # Define the 12 triangles composing the cube
    faces = np.array([
        [0,3,1],
        [1,3,2],
        [0,4,7],
        [0,7,3],
        [4,5,6],
        [4,6,7],
        [5,1,2],
        [5,2,6],
        [2,3,6],
        [3,7,6],
        [0,1,5],
        [0,5,4]
    ])

    cube = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))

    for i, f in enumerate(faces):
        for j in range(3):
            cube.vectors[i][j] = vertices[f[j],:]

    return cube.data

def generate_layer(image, z, thickness, output_filename, select = lambda x, y: True):
    cubes = []
    for x in range(image.size[0]):
        for y in range(image.size[1]):
            if not select(x, y):
                continue

            cube = put_pixel(x=x, y=y, z=z, thickness=thickness)

            if cube is not None:
                cubes.append(cube)

    if len(cubes) > 0:
        stl_mesh = mesh.Mesh(np.concatenate(cubes), remove_duplicate_polygons=False)
        stl_mesh.save(output_filename, mode=stl.Mode.ASCII)

colors = {
    "black": [ 0, 0, 0 ],
    "white": [ 255, 255, 255 ],
    "blue": [ 32, 105, 164 ],
}

flat_colors = [item for sublist in colors.values() for item in sublist]

palette = ImagePalette.ImagePalette(palette=flat_colors * 32)

with Image.open(argv[1]) as image:
    if image.mode == "RGBA":
        rgb_image = Image.new("RGB", image.size, (255, 255, 255))
        rgb_image.paste(image, mask=image.split()[3]) # remove alpha channel
    else:
        rgb_image = image

    resized_image = rgb_image.resize((RES, RES), Image.LANCZOS)

    image_palette = Image.new('P', resized_image.size)
    image_palette.putpalette(palette)

    dithered_image = resized_image.quantize(dither=Image.Dither.FLOYDSTEINBERG, palette=image_palette).load()

    # Generate black base layer, black to avoid light reflection
    generate_layer(
        image=resized_image,
        output_filename="base_black.stl",
        z=0,
        thickness=BASE_THICKNESS
    )
    generate_layer(
        image=resized_image,
        output_filename="base_white.stl",
        z=BASE_THICKNESS,
        thickness=BASE_THICKNESS
    )

    for index in range(len(colors)):
        generate_layer(
            image=resized_image,
            output_filename=f'{list(colors.keys())[index]}.stl',
            z=BASE_THICKNESS * 2, # We put the colors over the two base layers
            thickness=BASE_THICKNESS,
            select=lambda x, y : dithered_image[x, y] == index
        )
